<pre class=metadata>
Group: WHATWG
H1: WebSockets
Shortname: websockets
Text Macro: TWITTER whatsockets
Text Macro: LATESTRD 2023-09
Abstract: This specification provides APIs to enable web applications to maintain bidirectional
Abstract: communications with server-side processes.
Translation: ja https://triple-underscore.github.io/WebSocket-ja.html
Indent: 1
Markup Shorthands: markdown yes
</pre>

<pre class=biblio>
{
 "WSP": {
  "aliasOf": "RFC6455"
 },
 "HSTS": {
  "aliasOf": "RFC6797"
 }
}
</pre>

<pre class=link-defaults>
spec:url; type:interface;
 text:URL
spec:url; type:dfn;
 text:fragment
 text:scheme
spec:html; type:dfn;
 text:task queues
 for:/; text:event loop
spec:url; type:dfn;
 text:origin
 for:/; text:url
</pre>

<pre class=anchors>
spec:RFC6455; urlPrefix: https://datatracker.ietf.org/doc/html/rfc6455
 type: dfn
  text:the WebSocket connection is established; url:page-19:~:text=_The%20WebSocket%20Connection%20is%20Established_,-and
  text:extensions in use; url:page-19:~:text=_The%20WebSocket%20Connection%20is%20Established_,-and
  text:subprotocol in use; url:page-19:~:text=_Subprotocol%20In,Use_
  text:a WebSocket message has been received; url:page-66:~:text=_A%20WebSocket%20Message%20Has%20Been%20Received_
  text:send a WebSocket Message; url:page-66:~:text=needs%20to-,_Send%20a%20WebSocket%20Message_
  text:fail the WebSocket connection; url:section-7.1.7
  text:close the WebSocket connection; url:section-7.1.1
  text:start the WebSocket closing handshake; url:section-7.1.2
  text:the WebSocket closing handshake is started; url:section-7.1.3
  text:the WebSocket connection is closed; url:section-7.1.4
  text:the WebSocket connection close code; url:section-7.1.5
  text:the WebSocket connection close reason; url:section-7.1.6
  text:established; url:page-19:~:text=_The%20WebSocket%20Connection%20is%20Established_,-and
  text:ws; url:section-11.1.1
  text:wss; url:section-11.1.2
  text:cleanly; url:page-41:~:text=closed-,_cleanly_.
 type: http-header; text:Sec-WebSocket-Protocol; url:section-11.3.4
spec:html; type:dfn; urlPrefix: https://html.spec.whatwg.org/multipage/webappapis.html
 for:event loop; text:step 1; url:step1
</pre>


# Introduction # {#network-intro}

<div class="non-normative">

<em>This section is non-normative.</em>

To enable web applications to maintain bidirectional communications with server-side processes,
this specification introduces the {{WebSocket}} interface.

<p class="note">This interface does not allow for raw access to the underlying network. For
example, this interface could not be used to implement an IRC client without proxying messages
through a custom server.</p>
</div>


# WebSocket protocol alterations # {#websocket-protocol}

<div class=note>
 This section replaces part of the WebSocket protocol opening handshake client requirement to
 integrate it with algorithms defined in <cite>Fetch</cite>. This way CSP, cookies, HSTS, and other
 <cite>Fetch</cite>-related protocols are handled in a single location. Ideally the RFC would be
 updated with this language, but it is never that easy. The {{WebSocket}} API, defined below, uses
 this language. [[!WSP]] [[!FETCH]]

 The way this works is by replacing The WebSocket Protocol's "establish a WebSocket connection"
 algorithm with a new one that integrates with <cite>Fetch</cite>. "Establish a WebSocket
 connection" consists of three algorithms: setting up a connection, creating and transmiting a
 handshake request, and validating the handshake response. That layering is different from
 <cite>Fetch</cite>, which first creates a handshake, then sets up a connection and transmits the
 handshake, and finally validates the response. Keep that in mind while reading these alterations.
</div>


## Connections ## {#websocket-connections}

<div algorithm>

To <dfn export id=concept-websocket-connection-obtain>obtain a WebSocket connection</dfn>, given a
|url|, run these steps:

1. Let |host| be |url|'s <a for=url>host</a>.
1. Let |port| be |url|'s <a for=url>port</a>.
1. Let |resource name| be U+002F (/), followed by the strings in |url|'s <a for=url>path</a>
   (including empty strings), if any, separated from each other by U+002F (/).
1. If |url|'s <a for=url>query</a> is non-empty, append U+003F (?), followed by |url|'s
   <a for=url>query</a>, to |resource name|.
1. Let |secure| be false, if |url|'s [=url/scheme=] is "`http`"; otherwise true.
1. Follow the requirements stated in step 2 to 5, inclusive, of the first set of steps in <a
 href=https://datatracker.ietf.org/doc/html/rfc6455#section-4.1>section 4.1</a> of The WebSocket
 Protocol to establish a <a lt="obtain a WebSocket connection">WebSocket connection</a>, passing
 |host|, |port|, |resource name| and |secure|. [[!WSP]]
1. If that established a connection, return it, and return failure otherwise.

<p class=note>Although structured a little differently, carrying different properties, and
therefore not shareable, a WebSocket connection is very close to identical to an "ordinary"
[=connection=].

</div>


## Opening handshake ## {#websocket-opening-handshake}

<div algorithm>

To <dfn id=concept-websocket-establish>establish a WebSocket connection</dfn>, given a
|url|, |protocols|, and |client|, run these steps:

1. Let |requestURL| be a copy of |url|, with its [=url/scheme=] set to "`http`", if |url|'s
 [=url/scheme=] is "`ws`"; otherwise to "`https`".

 <p class="note no-backref">This change of scheme is essential to integrate well with
 <a lt=fetch for=/>fetching</a>. E.g., HSTS would not work without it. There is no real
 reason for WebSocket to have distinct schemes, it's a legacy artefact.
 [[!HSTS]]

1. Let |request| be a new <a for=/>request</a>, whose <a for=request>URL</a> is |requestURL|,
 <a for=request>client</a> is |client|, [=service-workers mode=] is "`none`",
 <a for=request>referrer</a> is "`no-referrer`", <a for=request>mode</a> is "`websocket`",
 <a for=request>credentials mode</a> is "`include`", <a for=request>cache mode</a> is "`no-store`"
 , and <a for=request>redirect mode</a> is "`error`".

1. <a for="header list">Append</a> (\``Upgrade`\`, \``websocket`\`) to |request|'s
 <a for=request>header list</a>.
1. <a for="header list">Append</a> (\``Connection`\`, \``Upgrade`\`) to |request|'s
 <a for=request>header list</a>.
1. Let |keyValue| be a nonce consisting of a randomly selected 16-byte value that has been
 <a lt="forgiving-base64 encode">forgiving-base64-encoded</a> and [=isomorphic encoded=].

 <p id=example-random-value class=example>If the randomly selected value was the byte sequence 0x01
  0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, |keyValue| would be
  forgiving-base64-encoded to "`AQIDBAUGBwgJCgsMDQ4PEC==`" and isomorphic encoded to
  \``AQIDBAUGBwgJCgsMDQ4PEC==`\`.

1. <a for="header list">Append</a> (\``Sec-WebSocket-Key`\`, |keyValue|) to |request|'s
 <a for=request>header list</a>.
1. <a for="header list">Append</a> (\``Sec-WebSocket-Version`\`, \``13`\`) to |request|'s
 <a for=request>header list</a>.
1. For each |protocol| in |protocols|, <a for="header list">combine</a>
 (\``Sec-WebSocket-Protocol`\`, |protocol|) in |request|'s <a for=request>header list</a>.

1. Let |permessageDeflate| be a user-agent defined "`permessage-deflate`" extension
 <a>header value</a>. [[!WSP]]

 <p id=example-permessage-deflate class=example>\``permessage-deflate; client_max_window_bits`\`

1. <a for="header list">Append</a> (\``Sec-WebSocket-Extensions`\`, |permessageDeflate|) to
 |request|'s <a for=request>header list</a>.
1. <a lt=fetch for=/>Fetch</a> |request| with <a for=fetch><i>useParallelQueue</i></a> set to true,
 and <a for=fetch><i>processResponse</i></a> given |response| being these steps:
 1. If |response| is a [=network error=] or its <a for=response>status</a> is not 101, [=fail the
  WebSocket connection=].
 1. If |protocols| is not the empty list and [=extracting header list values=] given
   \``Sec-WebSocket-Protocol`\` and |response|'s <a for=request>header list</a>
   results in null, failure, or the empty byte sequence, then [=fail the WebSocket connection=].

  <p class=note>This is different from the check on this header defined by The WebSocket Protocol.
  That only covers a subprotocol not requested by the client. This covers a subprotocol requested
  by the client, but not acknowledged by the server.

 1. Follow the requirements stated step 2 to step 6, inclusive, of the last set of steps in
  <a href=https://datatracker.ietf.org/doc/html/rfc6455#section-4.1>section 4.1</a> of The WebSocket
  Protocol to validate |response|. This either results in [=fail the WebSocket connection=]
  or [=the WebSocket connection is established=].

</div>

[=Fail the WebSocket connection=] and [=the WebSocket connection is established=] are defined by The
WebSocket Protocol. [[!WSP]]

<p class=warning>The reason redirects are not followed and this handshake is generally restricted is
because it could introduce serious security problems in a web browser context. For example, consider
a host with a WebSocket server at one path and an open HTTP redirector at another. Suddenly, any
script that can be given a particular WebSocket URL can be tricked into communicating to (and
potentially sharing secrets with) any host on the internet, even if the script checks that the URL
has the right hostname.
<!-- https://www.ietf.org/mail-archive/web/hybi/current/msg06951.html -->


# The {{WebSocket}} interface # {#the-websocket-interface}
## Interface definition ## {#interface-definition}

The Web IDL definition for the {{WebSocket}} class is given as follows:

<xmp class="idl">
enum BinaryType { "blob", "arraybuffer" };

[Exposed=(Window,Worker)]
interface WebSocket : EventTarget {
  constructor(USVString url, optional (DOMString or sequence<DOMString>) protocols = []);
  readonly attribute USVString url;

  // ready state
  const unsigned short CONNECTING = 0;
  const unsigned short OPEN = 1;
  const unsigned short CLOSING = 2;
  const unsigned short CLOSED = 3;
  readonly attribute unsigned short readyState;
  readonly attribute unsigned long long bufferedAmount;

  // networking
  attribute EventHandler onopen;
  attribute EventHandler onerror;
  attribute EventHandler onclose;
  readonly attribute DOMString extensions;
  readonly attribute DOMString protocol;
  undefined close(optional [Clamp] unsigned short code, optional USVString reason);

  // messaging
  attribute EventHandler onmessage;
  attribute BinaryType binaryType;
  undefined send((BufferSource or Blob or USVString) data);
};
</xmp>

Each {{WebSocket}} object has an associated <dfn for="WebSocket" lt="internal-url">url</dfn>, which
is a [=URL record=].

Each {{WebSocket}} object has an associated <dfn for="WebSocket">binary type</dfn>, which is a
{{BinaryType}}. Initially it must be "{{BinaryType/blob}}".

Each {{WebSocket}} object has an associated  <dfn for="WebSocket">ready state</dfn>, which is a
number representing the state of the connection. Initially it must be {{WebSocket/CONNECTING}} (0).
It can have the following values:

: <dfn const for=WebSocket>CONNECTING</dfn> (numeric value 0)
:: The connection has not yet been established.
: <dfn const for=WebSocket>OPEN</dfn> (numeric value 1)
:: [=The WebSocket connection is established=] and communication is possible.
: <dfn const for=WebSocket>CLOSING</dfn> (numeric value 2)
:: The connection is going through the
 closing handshake, or the {{WebSocket/close()}} method has been invoked.
: <dfn const for=WebSocket>CLOSED</dfn> (numeric value 3)
:: The connection has been closed or could not be opened.

<dl class="domintro non-normative">
 : <code>|socket| = new {{WebSocket/constructor(url, protocols)|WebSocket}}(|url| [, |protocols| ])</code>
 :: Creates a new {{WebSocket}} object, immediately establishing the associated WebSocket
    connection.

    |url| is a string giving the <a for=/>URL</a> over which the connection is established.
    Only "`ws`", "`wss`", "`http`", and "`https`" schemes are allowed; others will cause a
    "{{SyntaxError}}" {{DOMException}}. URLs with [=fragments=] will always cause such an exception.

    |protocols| is either a string or an array of strings. If it is a string, it is equivalent to
    an array consisting of just that string; if it is omitted, it is equivalent to the empty array.
    Each string in the array is a subprotocol name. The connection will only be established if the
    server reports that it has selected one of these subprotocols. The subprotocol names have to
    match the requirements for elements that comprise the value of \`<a
    http-header>`Sec-WebSocket-Protocol`</a>\` fields as defined by The WebSocket protocol.
    [[!WSP]]

 : <code>|socket|.<a method for=WebSocket lt=send()>send</a>(|data|)</code>
 :: Transmits |data| using the WebSocket connection. |data| can be a string, a {{Blob}}, an
    {{ArrayBuffer}}, or an {{ArrayBufferView}}.

 : <code>|socket|.<a method for=WebSocket>close</a>([ |code| ] [, |reason| ])</code>
 :: Closes the WebSocket connection, optionally using |code| as [=the WebSocket connection
    close code=] and |reason| as [=the WebSocket connection close reason=].

 : <code>|socket|.<a attribute for=WebSocket>url</a></code>
 :: Returns the <a lt="internal-url">URL that was used</a> to establish the WebSocket connection.

 : <code>|socket|.<a attribute for=WebSocket>readyState</a></code>
 :: Returns the state of the WebSocket connection. It can have the values described above.

 : <code>|socket|.<a attribute>bufferedAmount</a></code>
 :: Returns the number of bytes of application data (UTF-8 text and binary data) that have been
    queued using {{WebSocket/send()}} but not yet been transmitted to the network.

    If the WebSocket connection is closed, this attribute's value will only increase with each call
    to the {{WebSocket/send()}} method. (The number does not reset to zero once the connection
    closes.)

 : <code>|socket|.<a attribute>extensions</a></code>
 :: Returns the extensions selected by the server, if any.

 : <code>|socket|.<a attribute>protocol</a></code>
 :: Returns the subprotocol selected by the server, if any. It can be used in conjunction with the
    array form of the constructor's second argument to perform subprotocol negotiation.

 : <code>|socket|.<a attribute>binaryType</a></code>
 :: Returns a string that indicates how binary data from |socket| is exposed to scripts:

    : "{{BinaryType/blob}}"
    :: Binary data is returned in {{Blob}} form.
    : "{{BinaryType/arraybuffer}}"
    :: Binary data is returned in {{ArrayBuffer}} form.

    The default is "{{BinaryType/blob}}".

 : <code>|socket|.<a attribute>binaryType</a> = <var ignore>value</var></code>
 :: Changes how binary data is returned.
</dl>

<div algorithm>
 The <dfn constructor for="WebSocket" data-lt="WebSocket(url, protocols)"><code>new
 WebSocket(|url|, |protocols|)</code></dfn>
 constructor steps are:

 1. Let |baseURL| be [=this=]'s [=relevant settings object=]'s [=API base URL=].
 1. Let |urlRecord| be the result of [=getting a URL record=] given |url| and
    |baseURL|.
 1. If |protocols| is a string, set |protocols| to a sequence consisting of just that string.
 1. If any of the values in |protocols| occur more than once or otherwise fail to match the
    requirements for elements that comprise the value of
    \`<a http-header>`Sec-WebSocket-Protocol`</a>\` fields as defined by The WebSocket protocol,
    then throw a "{{SyntaxError}}" {{DOMException}}.  [[!WSP]]
 1. Set [=this=]'s [=WebSocket/internal-url|url=] to |urlRecord|.
 1. Let |client| be [=this=]'s [=relevant settings object=].
 1. Run this step [=in parallel=]:
  1. [=Establish a WebSocket connection=] given |urlRecord|, |protocols|, and |client|. [[!FETCH]]

     <p class="note">If the [=establish a WebSocket connection=] algorithm
     fails, it triggers the [=fail the WebSocket connection=] algorithm, which
     then invokes the [=close the WebSocket connection=] algorithm, which then
     establishes that [=the WebSocket connection is closed=], which fires the
     {{WebSocket/close}} event <a href="#closeWebSocket">as described below</a>.
</div>

<hr>

The <dfn attribute for=WebSocket>url</dfn> getter steps are to return [=this=]'s
[=WebSocket/internal-url|url=], [=URL serializer|serialized=].

The <dfn attribute for=WebSocket>readyState</dfn> getter steps are to return [=this=]'s
[=WebSocket/ready state=].

The <dfn attribute for=WebSocket>extensions</dfn> attribute must initially return the empty
string. After [=the WebSocket connection is established=], its value might change, as defined
below.</p>

The <dfn attribute for=WebSocket>protocol</dfn> attribute must initially return the empty
string. After [=the WebSocket connection is established=], its value might change, as defined below.

<div algorithm>
 The <dfn method for=WebSocket>close(|code|, |reason|)</dfn> method steps are:

  1. If |code| is the special value "missing", then set |code| to null.
  1. If |reason| is the special value "missing", then set |reason| to the empty string.
  1. [=Close the WebSocket=] with [=this=], |code|, and |reason|.

</div>

<p class="note">The {{WebSocket/close()}} method does not discard previously sent messages before
starting the WebSocket closing handshake &mdash; even if, in practice, the user agent is still busy
sending those messages, the handshake will only start after the messages are sent. <!-- this is
trivially true in this spec, because we don't buffer at all. We just tell the WebSocket API spec to
do it. -->

<hr>

The <dfn attribute for=WebSocket>bufferedAmount</dfn> getter steps are to return the number of bytes
of application data (UTF-8 text and binary data) that have been queued using {{WebSocket/send()}}
but that, as of the last time the [=event loop=] reached <a for="event loop">step 1</a>, had not yet
been transmitted to the network. (This thus includes any text sent during the execution of the
current task, regardless of whether the user agent is able to transmit text in the background [=in
parallel=] with script execution.) This does not include framing overhead incurred by the protocol,
or buffering done by the operating system or network hardware.

<div class="example" id="buffered-amount-example">

In this simple example, the {{WebSocket/bufferedAmount}} attribute is used to ensure that updates
are sent either at the rate of one update every 50ms, if the network can handle that rate, or at
whatever rate the network <em>can</em> handle, if that is too fast.

<xmp highlight="js">
var socket = new WebSocket('ws://game.example.com:12010/updates');
socket.onopen = function () {
  setInterval(function() {
    if (socket.bufferedAmount == 0)
      socket.send(getUpdateData());
  }, 50);
};
</xmp>

The {{WebSocket/bufferedAmount}} attribute can also be used to saturate the network without sending
the data at a higher rate than the network can handle, though this requires more careful monitoring
of the value of the attribute over time.

</div>

<hr>

The <dfn attribute for=WebSocket>binaryType</dfn> getter steps are to return [=this=]'s
[=WebSocket/binary type=].

The {{WebSocket/binaryType}} setter steps are to set [=this=]'s [=WebSocket/binary type=] to
[=the given value=].

<p class="note">User agents can use the [=WebSocket/binary type=] as a hint for how to handle
incoming binary data: if it is "{{BinaryType/blob}}", it is safe to spool it to disk, and if it is
"{{BinaryType/arraybuffer}}", it is likely more efficient to keep the data in memory. Naturally,
user agents are encouraged to use more subtle heuristics to decide whether to keep incoming data in
memory or not, e.g. based on how big the data is or how common it is for a script to change the
attribute at the last minute. This latter aspect is important in particular because it is quite
possible for the attribute to be changed after the user agent has received the data but before the
user agent has fired the event for it.

<div algorithm>
 The <dfn method for=WebSocket>send(|data|)</dfn> method steps are:

 1. If [=this=]'s [=WebSocket/ready state=] is {{WebSocket/CONNECTING}}, then throw an
    "{{InvalidStateError}}" {{DOMException}}.

 2. Run the appropriate set of steps from the following list:

    : If |data| is a string
    :: If [=the WebSocket connection is established=] and <a lt="the WebSocket closing handshake is
       started">the WebSocket closing handshake has not yet started</a>, then the user agent must
       [=send a WebSocket Message=] comprised of the |data| argument using a text frame opcode; if
       the data cannot be sent, e.g. because it would need to be buffered but the buffer is full,
       the user agent must <a lt="flagged as full">flag the WebSocket as full</a> and then [=close
       the WebSocket connection=]. Any invocation of this method with a string argument that does
       not throw an exception must increase the {{WebSocket/bufferedAmount}} attribute by the
       number of bytes needed to express the argument as UTF-8. [[!UNICODE]] [[!ENCODING]] [[!WSP]]


    : If |data| is a {{Blob}} object
    :: If [=the WebSocket connection is established=], and <a lt="the WebSocket closing handshake
       is started">the WebSocket closing handshake has not yet started</a>, then the user agent
       must [=send a WebSocket Message=] comprised of |data| using a binary frame opcode; if the
       data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the
       user agent must <a lt="flagged as full">flag the WebSocket as full</a> and then [=close the
       WebSocket connection=]. The data to be sent is the raw data represented by the {{Blob}}
       object.
       <!-- that sentence is meant to invoke "This interface represents immutable raw data." -->
       Any invocation of this method with a {{Blob}} argument that does not throw an exception must
       increase the {{WebSocket/bufferedAmount}} attribute by the size of the {{Blob}} object's raw
       data, in bytes.
       <!-- that sentence is meant to invoke the same as Blob.size -->
       [[!WSP]] [[!FILEAPI]]

    : If |data| is an {{ArrayBuffer}}
    :: If [=the WebSocket connection is established=], and <a lt="the WebSocket closing handshake
       is started">the WebSocket closing handshake has not yet started</a>, then the user agent
       must [=send a WebSocket Message=] comprised of |data| using a binary frame opcode; if the
       data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the
       user agent must <a lt="flagged as full">flag the WebSocket as full</a> and then [=close the
       WebSocket connection=]. The data to be sent is the data stored in the buffer described by
       the {{ArrayBuffer}} object. Any invocation of this method with an {{ArrayBuffer}} argument
       that does not throw an exception must increase the {{WebSocket/bufferedAmount}} attribute by
       the length of the {{ArrayBuffer}} in bytes. [[!WSP]]

    : If |data| is an {{ArrayBufferView}}
    :: If [=the WebSocket connection is established=], and <a lt="the WebSocket closing handshake
       is started">the WebSocket closing handshake has not yet started</a>, then the user agent
       must [=send a WebSocket Message=] comprised of |data| using a binary frame opcode; if the
       data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the
       user agent must <a lt="flagged as full">flag the WebSocket as full</a> and then [=close the
       WebSocket connection=]. The data to be sent is the data stored in the section of the buffer
       described by the {{ArrayBuffer}} object that |data| references. Any invocation of this
       method with this kind of argument that does not throw an exception must increase the
       {{WebSocket/bufferedAmount}} attribute by the length of |data|'s buffer in bytes. [[!WSP]]
</div>

<hr>

The following are the [=event handlers=] (and their corresponding [=event handler event types=])
that must be supported, as [=event handler IDL attributes=], by all objects implementing the
{{WebSocket}} interface:

<table>
<thead>
<tr><th>[=Event handler=] <th>[=Event handler event type=]
<tbody>
<tr><td><dfn attribute for=WebSocket>onopen</dfn> <td> {{WebSocket/open}}
<tr><td><dfn attribute for=WebSocket>onmessage</dfn> <td> {{WebSocket/message}}
<tr><td><dfn attribute for=WebSocket>onerror</dfn> <td> {{WebSocket/error}}
<tr><td><dfn attribute for=WebSocket>onclose</dfn> <td> {{WebSocket/close}}
</table>


## Feedback from the protocol ## {#feedback-from-the-protocol}

When [=the WebSocket connection is established=], the user agent must [=queue a task=] to run these
steps:

<div algorithm="handle connection establishment">

 1. Change the [=WebSocket/ready state=] to {{WebSocket/OPEN}} (1).
 1. Change the {{WebSocket/extensions}} attribute's value to the [=extensions in
    use=], if it is not the null value. [[!WSP]]
 1. Change the {{WebSocket/protocol}} attribute's value to the [=subprotocol in
    use=], if it is not the null value. [[!WSP]]
 1. [=Fire an event=] named <dfn event for="WebSocket">open</dfn> at the {{WebSocket}} object.

<p class="note">Since the algorithm above is <a lt="queue a task">queued as a task</a>, there is no
race condition between <a lt="the WebSocket connection is established">the WebSocket connection
being established</a> and the script setting up an event listener for the {{WebSocket/open}}
event.

</div>

<hr>

<div algorithm="handle a WebSocket message">

When [=a WebSocket message has been received=] with type |type| and data |data|, the user agent must
[=queue a task=] to follow these steps: [[!WSP]]

 1. If [=WebSocket/ready state=] is not {{WebSocket/OPEN}} (1), then return.
 1. Let |dataForEvent| be determined by switching on |type| and [=WebSocket/binary type=]:

  <dl class="switch">
   : |type| indicates that the data is Text
   :: a new {{DOMString}} containing |data|

   : |type| indicates that the data is Binary and [=WebSocket/binary type=] is
     <dfn enum-value for=BinaryType>"blob"</a>
   :: a new {{Blob}} object, created in the [=relevant Realm=] of the {{WebSocket}} object, that
      represents |data| as its raw data [[!FILEAPI]]

   : |type| indicates that the data is Binary and [=WebSocket/binary type=] is
     <dfn enum-value for=BinaryType>"arraybuffer"</dfn>
   :: a new {{ArrayBuffer}} object, created in the [=relevant Realm=] of the {{WebSocket}} object,
      whose contents are |data|
  </dl>

 1. [=Fire an event=] named <dfn event for="WebSocket">message</dfn> at the {{WebSocket}} object,
    using {{MessageEvent}}, with the {{MessageEvent/origin}} attribute initialized to the <a lt="URL
    serializer">serialization</a> of the {{WebSocket}} object's [=internal-url|url=]'s [=origin=],
    and the {{MessageEvent/data}} attribute initialized to |dataForEvent|.

<p class="note">User agents are encouraged to check if they can perform the above steps efficiently
before they run the task, picking tasks from other [=task queues=] while they prepare the buffers
if not. For example, if the [=WebSocket/binary type=] is "{{BinaryType/blob}}" when the data
arrived, and the user agent spooled all the data to disk, but just before running the above
[=task=] for this particular message the script switched [=WebSocket/binary type=] to
"{{BinaryType/arraybuffer}}", the user agent would want to page the data back to RAM before running
this [=task=] so as to avoid stalling the main thread while it created the {{ArrayBuffer}} object.

</div>

<div class="example" id="message-example">

Here is an example of how to define a handler for the {{WebSocket/message}} event in the case of
text frames:

<xmp highlight="js">
mysocket.onmessage = function (event) {
  if (event.data == 'on') {
    turnLampOn();
  } else if (event.data == 'off') {
    turnLampOff();
  }
};
</xmp>

The protocol here is a trivial one, with the server just sending "on" or "off" messages.

</div>

<hr>

When [=the WebSocket closing handshake is started=], the user agent must [=queue a task=] to change
the [=WebSocket/ready state=] to {{WebSocket/CLOSING}} (2). (If the {{WebSocket/close()}} method
was called, the [=WebSocket/ready state=] will already be set to {{WebSocket/CLOSING}} (2) when
this task runs.) [[!WSP]]

<hr>

<p id="closeWebSocket">When [=the WebSocket connection is closed=], possibly [=cleanly=], the user
 agent must [=queue a task=] to run the following substeps:

<div algorithm="handle connection close">
 1. Change the [=WebSocket/ready state=] to {{WebSocket/CLOSED}} (3).
 1. If the user agent was required to [=fail the WebSocket connection=], or if <a lt="the
    WebSocket connection is closed">the WebSocket connection was closed</a> after being <dfn>flagged
    as full</dfn>, [=fire an event=] named <dfn event for="WebSocket">error</dfn> at the
    {{WebSocket}} object. [[!WSP]]
 1. [=Fire an event=] named <dfn event for="WebSocket">close</dfn> at the {{WebSocket}} object,
    using {{CloseEvent}}, with the {{CloseEvent/wasClean}} attribute initialized to true if the
    connection closed [=cleanly=] and false otherwise, the {{CloseEvent/code}} attribute initialized
    to [=the WebSocket connection close code=], and the {{CloseEvent/reason}} attribute initialized
    to the result of applying [=UTF-8 decode without BOM=] to [=the WebSocket connection close
    reason=].  [[!WSP]]
</div>

<div class="warning">

User agents must not convey any failure information to scripts in a way that would allow a
script to distinguish the following situations:

 * A server whose host name could not be resolved.
 * A server to which packets could not successfully be routed.
 * A server that refused the connection on the specified port.
 * A server that failed to correctly perform a TLS handshake (e.g., the server certificate can't be
   verified).
 * A server that did not complete the opening handshake (e.g. because it was not a WebSocket
   server).
 * A WebSocket server that sent a correct opening handshake, but that specified options that caused
   the client to drop the connection (e.g. the server specified a subprotocol that the client did
   not offer).
 * A WebSocket server that abruptly closed the connection after successfully completing the
   opening handshake.

In all of these cases, [=the WebSocket connection close code=] would be 1006, as required by
<cite>WebSocket Protocol</cite>. [[!WSP]]

Allowing a script to distinguish these cases would allow a script to probe the user's local network
in preparation for an attack.

<p class="note">In particular, this means the code 1015 is not used by the user agent (unless the
server erroneously uses it in its close frame, of course).

</div>

<hr>

The [=task source=] for all [=tasks=] <a lt="queue a task">queued</a> in this section is the
<dfn export>WebSocket task source</dfn>.



## The {{CloseEvent}} interface ## {#the-closeevent-interface}

{{WebSocket}} objects use the {{CloseEvent}} interface for their {{WebSocket/close}} events:

<xmp class="idl">
[Exposed=(Window,Worker)]
interface CloseEvent : Event {
  constructor(DOMString type, optional CloseEventInit eventInitDict = {});

  readonly attribute boolean wasClean;
  readonly attribute unsigned short code;
  readonly attribute USVString reason;
};

dictionary CloseEventInit : EventInit {
  boolean wasClean = false;
  unsigned short code = 0;
  USVString reason = "";
};
</xmp>

<dl class="domintro">

 : |event| . {{CloseEvent/wasClean}}
 :: Returns true if the connection closed cleanly; false otherwise.
 : |event| . {{CloseEvent/code}}
 :: Returns the WebSocket connection close code provided by the server.
 : |event| . {{CloseEvent/reason}}
 :: Returns the WebSocket connection close reason provided by the server.

</dl>

The <dfn attribute for=CloseEvent>wasClean</dfn> attribute must return the value it was initialized
to. It represents whether the connection closed cleanly or not.

The <dfn attribute for=CloseEvent>code</dfn> attribute must return the value it was initialized
to. It represents the WebSocket connection close code provided by the server.

The <dfn attribute for=CloseEvent>reason</dfn> attribute must return the value it was initialized
to. It represents the WebSocket connection close reason provided by the server.



## Garbage collection ## {#garbage-collection}

A {{WebSocket}} object whose [=WebSocket/ready state=] was set to {{WebSocket/CONNECTING}} (0) as
of the last time the [=event loop=] reached <a for="event loop">step 1</a> must not be garbage
collected if there are any event listeners registered for {{WebSocket/open}} events,
{{WebSocket/message}} events, {{WebSocket/error}} events, or {{WebSocket/close}} events.

A {{WebSocket}} object whose [=WebSocket/ready state=] was set to {{WebSocket/OPEN}} (1) as of the
last time the [=event loop=] reached <a for="event loop">step 1</a> must not be garbage collected
if there are any event listeners registered for {{WebSocket/message}} events, {{WebSocket/error}},
or {{WebSocket/close}} events.

A {{WebSocket}} object whose [=WebSocket/ready state=] was set to {{WebSocket/CLOSING}} (2) as of
the last time the [=event loop=] reached <a for="event loop">step 1</a> must not be garbage
collected if there are any event listeners registered for {{WebSocket/error}} or {{WebSocket/close}}
events.

A {{WebSocket}} object with <a lt="the WebSocket connection is established">an established
connection</a> that has data queued to be transmitted to the network must not be garbage collected.
[[!WSP]]

If a {{WebSocket}} object is garbage collected while its connection is still open, the user agent
must [=start the WebSocket closing handshake=], with no status code<!--CLOSE CODE--> for the Close
message. [[!WSP]]

<hr>

If a user agent is to <dfn export>make disappear</dfn> a {{WebSocket}} object (this happens when a
{{Document}} object goes away), the user agent must follow the first appropriate set of steps from
the following list:

<div algorithm="to make disappear">

<dl class="switch">

 : If the WebSocket connection is not yet [=established=] [[!WSP]]
 :: [=Fail the WebSocket connection=]. [[!WSP]]
 : If the WebSocket closing handshake has not yet been
   <a lt="the WebSocket closing handshake is started">started</a> [[!WSP]]
 :: [=Start the WebSocket closing handshake=], with the status code<!--CLOSE CODE--> to use in the
    WebSocket Close frame being 1001. [[!WSP]]
 : Otherwise
 :: Do nothing.

</dl>

</div>



# The {{WebSocketStream}} interface # {#the-websocketstream-interface}

The Web IDL definition for the {{WebSocketStream}} class is given as follows:

<xmp class="idl">
dictionary WebSocketOpenInfo {
  ReadableStream readable;
  WritableStream writable;
  DOMString extensions;
  DOMString protocol;
};

dictionary WebSocketCloseInfo {
  [EnforceRange] unsigned short closeCode;
  USVString reason = "";
};

dictionary WebSocketStreamOptions {
  sequence<USVString> protocols;
  AbortSignal signal;
};

[Exposed=(Window,Worker)]
interface WebSocketStream {
  constructor(USVString url, optional WebSocketStreamOptions options = {});
  readonly attribute USVString url;
  readonly attribute Promise<WebSocketOpenInfo> opened;
  readonly attribute Promise<WebSocketCloseInfo> closed;
  undefined close(optional WebSocketCloseInfo closeInfo = {});
};
</xmp>

Each {{WebSocketStream}} object has an associated <dfn for="WebSocketStream">url</dfn>, which is a
[=URL record=].

Each {{WebSocketStream}} object has an associated <dfn for="WebSocketStream">opened promise</dfn>,
which is a promise.

Each {{WebSocketStream}} object has an associated <dfn for="WebSocketStream">closed promise</dfn>,
which is a promise.

Each {{WebSocketStream}} object has an associated <dfn for="WebSocketStream">readable stream</dfn>,
which is a {{ReadableStream}}.

Each {{WebSocketStream}} object has an associated <dfn for="WebSocketStream">writable stream</dfn>,
which is a {{WritableStream}}.

Each {{WebSocketStream}} object has an associated <dfn for="WebSocketStream">was ever
connected</dfn>, which is a boolean, initially false.

Each {{WebSocketStream}} object has an associated boolean <dfn for="WebSocketStream">handshake
aborted</dfn>, which is initially false.

Each {{WebSocketStream}} object has an associated <dfn for="WebSocketStream">ready state</dfn>,
which is a number representing the state of the connection. Initially it must be
{{WebSocket/CONNECTING}} (0). It has the same semantics as {{WebSocket}}'s [=WebSocket/ready
state=], but is not exposed to JavaScript.


<dl class="domintro non-normative">
 : <code>|socket| = new {{WebSocketStream/constructor(url, options)|WebSocketStream}}(|url|[, |options|])</code>
 :: Creates a new {{WebSocketStream}} object, immediately establishing the associated WebSocket
  connection.

  |url| is a string giving the <a dfn spec=url>URL</a> over which the connection is established.
  Only "`ws`", "`wss`", "`http`", and "`https`" schemes are allowed; others will cause a
  "{{SyntaxError}}" {{DOMException}}. URLs with [=fragments=] will also cause such an exception.

  The |options| argument is an object whose properties can be set as follows:

  : {{WebSocketStreamOptions/protocols}}
  :: An array of strings. If it is omitted, it is equivalent to an empty array. Each string in the
   array is a subprotocol name. The connection will only be established if the server reports that
   it has selected one of these subprotocols. The subprotocol names have to match the requirements
   for elements that comprise the value of \`<a http-header>`Sec-WebSocket-Protocol`</a>\` fields as
   defined by <cite>The WebSocket Protocol</cite>.  [[!WSP]]

  : {{WebSocketStreamOptions/signal}}
  :: An {{AbortSignal}} that can be used to abort the handshake. After the handshake is complete,
   the signal does nothing.

 : <code>|socket|.{{WebSocketStream/url}}</code>
 :: Returns the [=WebSocketStream/url|URL=] that was used</a> to establish the WebSocket connection.

 : <code>|socket|.{{WebSocketStream/opened}}</code>
 :: Returns a {{Promise}} which resolves when the handshake successfully completes, or rejects if
  the handshake fails. On success, it resolves to an object with the following properties:

  : {{WebSocketOpenInfo/readable}}
  :: A {{ReadableStream}} that can be used to read messages from the server. Each chunk read
   corresponds to one message. Text messages will be read as strings; binary messages will be read
   as {{Uint8Array}} objects.

    <p class=note>The original {{WebSocket}} API supplied {{ArrayBuffer}} objects, but modern
    practice is to prefer the {{Uint8Array}} type for binary data, particularly when using streams.
    The underlying {{ArrayBuffer}} object can be recovered by accessing <code><var
    ignore>chunk</var>.buffer</code>.

   The stream can be closed by calling {{ReadableStream/cancel()}} on
   {{WebSocketOpenInfo/readable}}. If the reason argument passed to {{ReadableStream/cancel()}} is a
   {{WebSocketError}} object then {{WebSocketError/closeCode}} will be used as [=the WebSocket
   connection close code=] and {{WebSocketError/reason}} will be used as [=the WebSocket connection
   close reason=].

   If no messages are read, or if messages are read slower than they are sent, then backpressure
   will be applied and eventually the server will stop sending new messages.

  : {{WebSocketOpenInfo/writable}}
  :: A {{WritableStream}} that can be used to send messages to the server. Each chunk written will
   be converted to one message. Strings will be sent as text messages; {{BufferSource}} chunks will
   be sent as binary messages. Backpressure due to the network or server being unable to process
   data fast enough will automatically be observed by piping. When using a [=writable stream
   writer=], waiting for the {{WritableStreamDefaultWriter/ready|writer.ready}} promise will ensure
   that backpressure is obeyed.

   The WebSocket can be closed by calling {{WritableStream/close()}} on
   {{WebSocketOpenInfo/writable}}.

   The stream can also be closed by calling {{WritableStream/abort()}} on
   {{WebSocketOpenInfo/writable}}. If the reason passed to {{WritableStream/abort()}} is a
   {{WebSocketError}}, then it will be used to set [=the WebSocket connection close code=] and
   [=the WebSocket connection close reason=] as with {{ReadableStream/cancel()}} above.

  : {{WebSocketOpenInfo/extensions}}
  :: The [=extensions in use=] for the connection.

  : {{WebSocketOpenInfo/protocol}}
  :: The [=subprotocol in use=] for the connection.

 : <code>|socket|.{{WebSocketStream/closed}}</code>
 :: A {{Promise}} which resolves when the connection is closed. If the connection did not close
  [=cleanly=] then the promise is rejected with a {{WebSocketError}}. When the connection closes
  [=cleanly=] the promise is fulfilled with an object with properties
  {{WebSocketCloseInfo/closeCode}} and {{WebSocketCloseInfo/reason}}, giving [=the WebSocket
  connection close code=] and [=the WebSocket connection close reason=] that were supplied by the
  server.

 : <code>|socket|.{{WebSocketStream/close()}}</code>
 : <code>|socket|.{{WebSocketStream/close()|close}}({ {{WebSocketCloseInfo/closeCode}}, {{WebSocketCloseInfo/reason}} })</code>
 :: Close the connection, optionally supplying an object with {{WebSocketCloseInfo/closeCode}} and
  {{WebSocketCloseInfo/reason}} properties to indicate [=the WebSocket connection close code=] and
  [=the WebSocket connection close reason=] that will be sent to the remote server. If the handshake
  is still in progress, then it will be aborted and {{WebSocketCloseInfo/closeCode}} and
  {{WebSocketCloseInfo/reason}} will be ignored.
</dl>

<div algorithm>

 The <dfn constructor for="WebSocketStream" data-lt="WebSocketStream(url, options)"><code>new
 WebSocketStream(|url|, |options|)</code></dfn> constructor steps are:

 1. Let |baseURL| be [=this=]'s [=relevant settings object=]'s [=API base URL=].
 1. Let |urlRecord| be the result of [=get a URL record|getting a URL record=] given |url| and
    |baseURL|.
 1. Let |protocols| be |options|["{{WebSocketStreamOptions/protocols}}"] if it [=map/exists=],
    otherwise an empty sequence.
 1. If any of the values in |protocols| occur more than once or otherwise fail to match the
    requirements for elements that comprise the value of
    \`<a http-header>`Sec-WebSocket-Protocol`</a>\` fields as defined by <cite>The WebSocket
    Protocol</cite>, then throw a "{{SyntaxError}}" {{DOMException}}. [[!WSP]]
 1. Set [=this=]'s [=WebSocketStream/url=] to |urlRecord|.
 1. Set [=this=]'s [=WebSocketStream/opened promise=] and [=WebSocketStream/closed promise=] to new
    promises.
 1. Apply backpressure to the WebSocket.

  <p class=note>This means that messages won't be read until the application is ready for them.

 1. If |options|["{{WebSocketStreamOptions/signal}}"] [=map/exists=],
  1. Let |signal| be |options|["{{WebSocketStreamOptions/signal}}"].
  1. If |signal| is [=AbortSignal/aborted=], then reject [=this=]'s [=WebSocketStream/opened
     promise=] and [=WebSocketStream/closed promise=] with |signal|'s [=abort reason=] and return.
  1. [=AbortSignal/add|Add the following abort steps=] to |signal|:
   1. If the WebSocket connection is not yet [=established=]: [[!WSP]]
    1. [=Fail the WebSocket connection=].
    1. Set [=this=]'s [=WebSocketStream/ready state=] to {{WebSocket/CLOSING}}.
    1. [=Reject=] [=this=]'s [=WebSocketStream/opened promise=] and [=WebSocketStream/closed
       promise=] with |signal|'s [=abort reason=].
    1. Set [=this=]'s [=WebSocketStream/handshake aborted=] to true.
 1. Let |client| be [=this=]'s [=relevant settings object=].
 1. Run this step [=in parallel=]:
  1. [=Establish a WebSocket connection=] given |urlRecord|, |protocols|, and |client|. [[!FETCH]]

     <p class="note">If the [=establish a WebSocket connection=] algorithm fails, it triggers the
     [=fail the WebSocket connection=] algorithm, which then invokes the [=close the WebSocket
     connection=] algorithm. This establishes that [=the WebSocket connection is closed=], which
     <a>rejects</a> the {{WebSocketStream/opened}} and {{WebSocketStream/closed}} promises.
</div>

<hr>

The <dfn attribute for=WebSocketStream>url</dfn> getter steps are to return [=this=]'s
[=WebSocketStream/url=], [=URL serializer|serialized=].

The <dfn attribute for=WebSocketStream>opened</dfn> getter steps are to return [=this=]'s
[=WebSocketStream/opened promise=].

The <dfn attribute for=WebSocketStream>closed</dfn> getter steps are to return [=this=]'s
[=WebSocketStream/closed promise=].

<div algorithm>
 The <dfn method for=WebSocketStream>close(|closeInfo|)</dfn> method steps are:

 1. Let |code| be |closeInfo|["{{WebSocketCloseInfo/closeCode}}"] if present, or null otherwise.
 1. Let |reason| be |closeInfo|["{{WebSocketCloseInfo/reason}}"].
 1. [=Close the WebSocket=] with <var ignore>this</var>, |code|, and |reason|.
</div>


## Feedback to WebSocketStream from the protocol ## {#feedback-to-websocket-stream-from-the-protocol}

When [=the WebSocket connection is established=] for a {{WebSocketStream}} |stream|, the user agent
must [=queue a global task=] on the [=WebSocket task source=] given |stream|'s [=relevant global
object=] to run these steps:

<div algorithm="handle WebSocketStream connection establishment">

 1. Change |stream|'s [=WebSocketStream/ready state=] to {{WebSocket/OPEN}} (1).
 1. Set |stream|'s [=WebSocketStream/was ever connected=] to true.
 1. Let |extensions| be the [=extensions in use=].
 1. Let |protocol| be the [=subprotocol in use=].
 1. Let |pullAlgorithm| be an action that [=pulls bytes=] from |stream|.
 1. Let |cancelAlgorithm| be an action that [=cancels=] |stream| with
    |reason|, given |reason|.
 1. Let |readable| be a [=new=] {{ReadableStream}}.
 1. [=ReadableStream/Set up=] |readable| with |pullAlgorithm| and |cancelAlgorithm|.
 1. Let |writeAlgorithm| be an action that [=writes=] |chunk| to |stream|, given |chunk|.
 1. Let |closeAlgorithm| be an action that [=closes=] |stream|.
 1. Let |abortAlgorithm| be an action that [=aborts=] |stream| with |reason|, given |reason|.
 1. Let |writable| be a [=new=] {{WritableStream}}.
 1. [=WritableStream/Set up=] |writable| with |writeAlgorithm|, |closeAlgorithm|, and
    |abortAlgorithm|.
 1. Set |stream|'s [=WebSocketStream/readable stream=] to |readable|.
 1. Set |stream|'s [=WebSocketStream/writable stream=] to |writable|.
 1. [=Resolve=] |stream|'s [=WebSocketStream/opened promise=] with {{WebSocketOpenInfo}} «[
    "{{WebSocketOpenInfo/extensions}}" → |extensions|, "{{WebSocketOpenInfo/protocol}}" →
    |protocol|, "{{WebSocketOpenInfo/readable}}" → |readable|, "{{WebSocketOpenInfo/writable}}" →
    |writable| ]».

</div>

<hr>

<div algorithm="handle a WebSocketStream message">

When [=a WebSocket message has been received=] for a {{WebSocketStream}} |stream| with type |type|
and data |data|, the user agent must [=queue a global task=] on the [=WebSocket task source=] given
|stream|'s [=relevant global object=] to follow these steps: [[!WSP]]

 1. If |stream|'s [=WebSocketStream/ready state=] is not {{WebSocket/OPEN}} (1), then return.
 1. Let |chunk| be determined by switching on |type|:

  <dl class="switch">
   : |type| indicates that the data is Text
   :: a new {{DOMString}} containing |data|

   : |type| indicates that the data is Binary
   :: a new {{Uint8Array}} object, created in the [=relevant Realm=] of the {{WebSocketStream}}
      object, whose contents are |data|
  </dl>

 1. [=ReadableStream/Enqueue=] |chunk| into |stream|'s [=WebSocketStream/readable stream=].
 1. Apply backpressure to the WebSocket.

 <p class=note>Applying backpressure will result in no new WebSocket messages being handled until
 the backpressure is released. After an implementation-defined amount of data is buffered, the
 client will stop reading from the underlying network connection resulting in network-layer
 backpressure being applied.
</div>

<hr>

When [=the WebSocket closing handshake is started=] for a {{WebSocketStream}}
|stream|, the user agent must [=queue a global task=] on the [=WebSocket task source=] given
|stream|'s [=relevant global object=] to change |stream|'s [=WebSocketStream/ready state=] to
{{WebSocket/CLOSING}} [[!WSP]]

<hr>

<div algorithm="handle WebSocketStream connection close">

When [=the WebSocket connection is closed=] for a {{WebSocketStream}} |stream|, possibly
[=cleanly=], the user agent must [=queue a global task=] on the [=WebSocket task source=] given
|stream|'s [=relevant global object=] to run the following substeps:

 1. Change |stream|'s [=WebSocketStream/ready state=] to {{WebSocket/CLOSED}} (3).
 1. If |stream|'s [=WebSocketStream/handshake aborted=] is true, then return.
 1. If |stream|'s [=WebSocketStream/was ever connected=] is false, then [=reject=] |stream|'s
    [=opened promise=] with a [=new=] {{WebSocketError}}.
 1. Let |code| be [=the WebSocket connection close code=].
 1. Let |reason| be the result of applying [=UTF-8 decode without BOM=] to [=the WebSocket
    connection close reason=].
 1. If the connection was closed [=cleanly=],
  1. [=ReadableStream/Close=] |stream|'s [=WebSocketStream/readable stream=].
  1. [=WritableStream/Error=] |stream|'s [=WebSocketStream/writable stream=] with an
     "{{InvalidStateError}}" {{DOMException}} indicating that a closed {{WebSocketStream}} cannot be
     written to.
  1. [=Resolve=] |stream|'s [=closed promise=] with {{WebSocketCloseInfo}} «[
    "{{WebSocketCloseInfo/closeCode}}" → |code|, "{{WebSocketCloseInfo/reason}}" → |reason| ]».
 1. Otherwise,
  1. Let |error| be a [=new=]
     {{WebSocketError}} whose [=WebSocketError/closeCode=] is |code| and [=WebSocketError/reason=]
     is |reason|.
  1. [=ReadableStream/Error=] |stream|'s [=WebSocketStream/readable stream=] with |error|.
  1. [=WritableStream/Error=] |stream|'s [=WebSocketStream/writable stream=] with |error|.
  1. [=Reject=] |stream|'s [=closed promise=] with |error|.
</div>



## Stream operations ## {#stream-operations}

<div algorithm="pull algorithm">

To <dfn>pull bytes</dfn> from a {{WebSocketStream}} |stream|, if |stream| is currently applying
backpressure, release backpressure.

 <p class=note>If any messages are queued, one will be handled immediately as a result.
</div>

<hr>

<div algorithm="cancel algorithm">

To <dfn>cancel</dfn> a {{WebSocketStream}} |stream| given |reason|, [=close using reason=] giving
|stream| and |reason|.
</div>

<hr>

<div algorithm="write algorithm">

To <dfn>write</dfn> |chunk| to a {{WebSocketStream}} |stream|:
 1. Let |promise| be [=a new promise=] created in |stream|'s [=relevant realm=].
 1. Let |data| be null.
 1. Let |opcode| be null.
 1. If |chunk| is a {{BufferSource}},
  1. Set |data| to a [=get a copy of the buffer source|copy of the bytes=] given |chunk|.
  1. Set |opcode| to a binary frame opcode.
 1. Otherwise,
  1. Let |string| be the result of [=Converted to an IDL value|converting=] |chunk| to an IDL
     {{USVString}}. If this throws an exception, return [=a promise rejected with=] the exception.
  1. Set |data| to the result of [=UTF-8 encoding=] |string|.
  1. Set |opcode| to a text frame opcode.
 1. In parallel,
  1. Wait until there is sufficient buffer space in |stream| to send the message.

   <p class=note>This means that backpressure will be applied when the user agent's buffers are
   full.

  1. If [=the WebSocket closing handshake is started|the closing handshake has not yet started=],
     [=Send a WebSocket Message=] to |stream| comprised of |data| using |opcode|.
  1. [=Queue a global task=] on the [=WebSocket task source=] given |stream|'s [=relevant global
     object=] to resolve |promise| with undefined.
 1. Return |promise|.
</div>

<hr>

<div algorithm="close algorithm">

To <dfn>close</dfn> a {{WebSocketStream}} |stream|, [=close the WebSocket=] with |stream| (<var
ignore>code</var> and <var ignore>reason</var> are not set).
</div>

<hr>

<div algorithm="abort algorithm">

To <dfn>abort</dfn> a {{WebSocketStream}} |stream| given |reason|, [=close using reason=] giving
|stream| and |reason|.
</div>

<hr>

<div algorithm="close using reason algorithm">

To <dfn>close using reason</dfn> a {{WebSocketStream}} |stream| given |reason|:

 1. Let |code| be null.
 1. Let |reasonString| be the empty string.
 1. If |reason| [=implements=] {{WebSocketError}},
  1. Set |code| to |reason|'s [=WebSocketError/closeCode=].
  1. Set |reasonString| to |reason|'s [=WebSocketError/reason=].
 1. [=Close the WebSocket=] with |stream|, |code|, and |reasonString|. If this throws an exception,
  discard |code| and |reasonString| and [=close the WebSocket=] with |stream|.

 <p class=note>A {{WebSocketError}} object constructed from JavaScript will always have a
 [=WebSocketError/closeCode=] and [=WebSocketError/reason=] that JavaScript is permitted to set.
 However, the {{WebSocketStream/closed}} promise might be rejected with a {{WebSocketError}} whose
 [=WebSocketError/closeCode=] has a value coming from the server that JavaScript is not permitted to
 set itself, such as 1001 "Going Away".
</div>



## The {{WebSocketError}} interface ## {#the-websocketevent-interface}

<dfn interface>WebSocketError</dfn> is a subclass of {{DOMException}}
that represents the information associated with closing a WebSocket.

<xmp class="idl">
[Exposed=(Window,Worker)]
interface WebSocketError : DOMException {
  constructor(optional DOMString message = "",
              optional WebSocketCloseInfo init = {});

  readonly attribute unsigned short? closeCode;
  readonly attribute USVString reason;
};
</xmp>

Each {{WebSocketError}} object has an associated <dfn for="WebSocketError">closeCode</dfn>, which is
a number or null, and defaults to null.

Each {{WebSocketError}} object has an associated <dfn for="WebSocketError">reason</dfn>, which is a
string, and defaults to the empty string.

<dl class="domintro non-normative">
 : <code>|error| = new {{WebSocketError/constructor(message, init)|WebSocketError}}([|message|[,
   |init|]])</code>
 :: Creates a new {{WebSocketError}} object.

  |message| is a string which will be used to initialize the {{DOMException/message}} attribute of
  the base class.

  The |init| argument is an object whose properties can be set as follows:

  : {{WebSocketCloseInfo/closeCode}}
  :: A number, either 1000 or any integer in the range 3000 to 4999, inclusive. Any other
   number will result in an "{{InvalidAccessError}}" {{DOMException}}. If a non-empty
   {{WebSocketCloseInfo/reason}} is set, defaults to 1000, since there is no way to send a non-empty
   reason without a close code.
  : {{WebSocketCloseInfo/reason}}
  :: A string. Must be 123 bytes or less when converted to [=UTF-8=]. A longer string will result in
   a "{{SyntaxError}}" {{DOMException}} being thrown. Defaults to the empty string.

 : <code>|error|.{{WebSocketError/closeCode}}</code>
 :: Returns the [=the WebSocket connection close code=].

 : <code>|error|.{{WebSocketError/reason}}</code>
 :: Returns the [=the WebSocket connection close reason=].
</dl>

<hr>

<div algorithm>

The <dfn constructor for="WebSocketError" data-lt="WebSocketError(message, init)"><code>new
WebSocketError(|message|, |init|)</code></dfn> constructor steps are:

 1. Set [=this=]'s [=DOMException/name=] to "<code>WebSocketError</code>".
 1. Set [=this=]'s [=DOMException/message=] to |message|.
 1. Let |code| be |init|["{{WebSocketCloseInfo/closeCode}}"] if it [=map/exists=], or null
    otherwise.
 1. Let |reason| be |init|["{{WebSocketCloseInfo/reason}}"] if it [=map/exists=], or the empty
    string otherwise.
 1. [=Validate close code and reason=] with |code| and |reason|.
 1. If |reason| is non-empty, but |code| is null, then set |code| to 1000 ("Normal Closure").
 1. Set [=this=]'s [=WebSocketError/closeCode=] to |code|.
 1. Set [=this=]'s [=WebSocketError/reason=] to |reason|.
</div>

The <dfn attribute for=WebSocketError>closeCode</dfn> getter steps are to return [=this=]'s
[=WebSocketError/closeCode=].

The <dfn attribute for=WebSocketError>reason</dfn> getter steps are to return [=this=]'s
[=WebSocketError/reason=].

# Common algorithms # {#common-algorithms}

These algorithms are shared between the {{WebSocket}} and {{WebSocketStream}} interfaces.

<div algorithm>

To <dfn>get a URL record</dfn> given a |url| and |baseURL|:

 1. Let |urlRecord| be the result of applying the [=URL parser=] to |url| with |baseURL|.
 1. If |urlRecord| is failure, then throw a "{{SyntaxError}}" {{DOMException}}.
 1. If |urlRecord|'s [=url/scheme=] is "`http`", then set |urlRecord|'s [=url/scheme=] to
    "<code>[=ws=]</code>".
 1. Otherwise, if |urlRecord|'s [=url/scheme=] is "`https`", set |urlRecord|'s [=url/scheme=] to
    "<code>[=wss=]</code>".
 1. If |urlRecord|'s [=scheme=] is not "<code>[=ws=]</code>" or "<code>[=wss=]</code>", then throw a
    "{{SyntaxError}}" {{DOMException}}.
 1. If |urlRecord|'s [=fragment=] is non-null, then throw a "{{SyntaxError}}" {{DOMException}}.
 1. Return |urlRecord|.
</div>

<hr>

<div algorithm>

To <dfn>validate close code and reason</dfn> given a |code| and |reason|:

 1. If |code| is not null, but is neither an integer equal to 1000 nor an integer in the range 3000
    to 4999, inclusive, throw an "{{InvalidAccessError}}" {{DOMException}}.
 1. If |reason| is not null, then:
  1. Let |reasonBytes| be the result of [=UTF-8 encoding=] |reason|.
  1. If |reasonBytes| is longer than 123 bytes, then throw a "{{SyntaxError}}" {{DOMException}}.
</div>

<hr>

<div algorithm>

To <dfn>close the WebSocket</dfn> for a {{WebSocket}} or {{WebSocketStream}} |object|, given
optional |code| and optional |reason|:

 1. If |code| was not supplied, let |code| be null.
 1. If |reason| was not supplied, let |reason| be the empty string.
 1. [=Validate close code and reason=] with |code| and |reason|.
 1. Run the first matching steps from the following list:
  <dl class="switch">
  : If |object|'s [=WebSocket/ready state=] is {{WebSocket/CLOSING}} (2) or {{WebSocket/CLOSED}} (3)
  :: Do nothing.

   <p class="note">The connection is already closing or is already closed. If it has not already, a
   {{WebSocket/close}} event will eventually fire if |object| is a {{WebSocket}}, or the
   {{WebSocketStream/closed}} promise will become settled if |object| is a {{WebSocketStream}}.

  : If the WebSocket connection is not yet [=established=] [[!WSP]]
  :: [=Fail the WebSocket connection=] and set |object|'s [=WebSocket/ready state=] to
     {{WebSocket/CLOSING}} (2). [[!WSP]]

     <p class="note">The [=fail the WebSocket connection=] algorithm invokes the [=close the
     WebSocket connection=] algorithm, which then establishes that [=the WebSocket connection is
     closed=], which fires the {{WebSocket/close}} event if |object| is a {{WebSocket}}, or settles
     the {{WebSocketStream/closed}} promise if |object| is a {{WebSocketStream}}.

  : If the WebSocket closing handshake has not yet been <a lt="the WebSocket closing handshake is
    started">started</a> [[!WSP]]
  :: [=Start the WebSocket closing handshake=] and set |object|'s [=WebSocket/ready state=] to
     {{WebSocket/CLOSING}} (2). [[!WSP]]

     If |code| is null and |reason| is the empty string, the WebSocket Close frame must not have a
     body.

     <p class="note"><cite>The WebSocket Protocol</cite> erroneously states that the status code is
     <span class=allow-2119>required</a> for the [=start the WebSocket closing handshake=]
     algorithm. <!-- TODO(ricea): File an errata against RFC6455. -->

     if |reason| is non-empty but |code| is null, then set |code| to 1000 ("Normal Closure").

     If |code| is set, then the status code<!--CLOSE CODE--> to use in the WebSocket Close
     frame must be the integer given by |code|. [[!WSP]]

     If |reason| is non-empty, then |reason|, <a lt="UTF-8 encode">encoded as UTF-8</a>, must be
     provided in the Close frame after the status code<!--CLOSE CODE-->. [[!WSP]]

     <p class="note">The [=start the WebSocket closing handshake=] algorithm eventually invokes the
     [=close the WebSocket connection=] algorithm, which then establishes that [=the WebSocket
     connection is closed=], which fires the {{WebSocket/close}} event if |object| is a
     {{WebSocket}}, or settles the {{WebSocketStream/closed}} promise if |object| is a
     {{WebSocketStream}}.

  : Otherwise
  :: Set |object|'s [=WebSocket/ready state=] to {{WebSocket/CLOSING}} (2).

     <p class="note">[=The WebSocket closing handshake is started=], and will eventually invoke the
     [=close the WebSocket connection=] algorithm, which will establish that [=the WebSocket
     connection is closed=], and thus the {{WebSocket/close}} event will fire or the
     {{WebSocketStream/closed}} promise will resolve, depending on the type of |object|.
   </dl>


# Ping and Pong frames # {#ping-and-pong-frames}

<cite>The WebSocket Protocol</cite> defines Ping and Pong frames that can be used for keep-alive,
heart-beats, network status probing, latency instrumentation, and so forth. These are not currently
exposed in the API.

User agents may send ping and unsolicited pong frames as desired, for example in an attempt to
maintain local network NAT mappings, to detect failed connections, or to display latency metrics to
the user. User agents must not use pings or unsolicited pongs to aid the server; it is assumed that
servers will solicit pongs whenever appropriate for the server's needs.

<!-- v2: we'll probably add a way to make the client send pings and automatically terminate the
connection if they don't get a pong within an author-provided timeout; see
https://www.w3.org/Bugs/Public/show_bug.cgi?id=17264 -->



<h2 id="acks" class="no-num">Acknowledgments</h2>

Until the creation of this standard in 2021, the text here was maintained in the <a
href="https://html.spec.whatwg.org/multipage/">HTML Standard</a> and <a
href="https://fetch.spec.whatwg.org/">Fetch Standard</a>. Thanks to all of the contributors to those
repositories who helped develop the specification, especially Ian Hickson and Anne van Kesteren as
the respective original authors.

Thanks to
devsnek<!-- GitHub --> and
平野裕 (Yutaka Hirano)
for their contributions after the creation of the WebSockets Standard.

This standard is written by Adam Rice (<a href="https://google.com">Google</a>, <a
href="mailto:ricea@chromium.org">ricea@chromium.org</a>).
